<!doctype html>  
<html lang="en">  
<head>  
	<meta charset="utf-8">  
	<title>CANVAS!</title>  
	<style>
				body{
			font-family: Arial;}
		h1{
			font-size:42px;
			color:rgb(255,165,0);
			margin: 0 0 25px 0;}
		#canvas{
			border:1px solid black;}
		#container{
			width:800px;
			margin:0 auto;
			text-align: center;
			overflow: auto;}
		ul{
			list-style: none;
			padding:0;
			margin:0 auto;}
		li{
			float:left;
			margin:0;
			width: 33%;}
		input{
			display: block;
			margin: 0 auto;}
		span{
			font-size: 16px;
			display: block;
			margin: 0 auto;
			font-weight: bold;}
		p{
			font-size: 10px;
			padding: 0 25px;}
	</style>
<head>
<body>  
	<div id="container">
		<h1>CANVAS!</h1>

		<ul>
			<li>
				<span class="title">Bubble Sort</span>
				<canvas id="canvas-bubble-sort" width="200px" height="200px"></canvas>
				<p>
					Bubble sort is a simple sorting algorithm. The algorithm starts at the beginning of the data set. It compares the first two elements, and if the first is greater than the second, it swaps them. It continues doing this for each pair of adjacent elements to the end of the data set. It then starts again with the first two elements, repeating until no swaps have occurred on the last pass. This algorithm's average and worst case performance is O(n2), so it is rarely used to sort large, unordered, data sets.
				</p>
				<input type="button" value="Run Demo" id="btnBubbleSort">
			</li>
			<li>
				<span class="title">Selection Sort</span>
				<canvas id="canvas-selection-sort" width="200px" height="200px"></canvas>
				<p>
					Selection sort is an in-place comparison sort. It has O(n2) complexity, making it inefficient on large lists, and generally performs worse than the similar insertion sort. Selection sort is noted for its simplicity, and also has performance advantages over more complicated algorithms in certain situations. The algorithm finds the minimum value, swaps it with the value in the first position, and repeats these steps for the remainder of the list. It does no more than n swaps, and thus is useful where swapping is very expensive.
				</p>
				<input type="button" value="Run Demo" id="btnSelectionSort">
			</li>
			<li>
				<span class="title">Insertion Sort</span>
				<canvas id="canvas-insert-sort" width="200px" height="200px"></canvas>
				<p>
					Insertion sort is a simple sorting algorithm that is relatively efficient for small lists and mostly sorted lists, and often is used as part of more sophisticated algorithms. It works by taking elements from the list one by one and inserting them in their correct position into a new sorted list. In arrays, the new list and the remaining elements can share the array's space, but insertion is expensive, requiring shifting all following elements over by one. Shell sort is a variant of insertion sort that is more efficient for larger lists.
				</p>
				<input type="button" value="Run Demo" id="btnInsertionSort">
			</li>
		</ul>
	</div>
	
	</script>
	
		var sort = function(canvasId, strokeStyle, canvasSize){
			this.canvasId 		= canvasId;
			this.arraySize 		= canvasSize;
			this.canvasWidth 	= canvasSize;
			this.canvasHeight 	= canvasSize;

			if(!document.getElementById(canvasId)){
				alert('Canvas not found: ' + canvasId);
				return;
			}
			this.canvas = document.getElementById(canvasId);
			this.canvas.width 	= this.canvasWidth;
			this.canvas.height 	= this.canvasHeight;

			if(!this.canvas.getContext){
				alert('Canvas not supported!');
				return;
			}
			this.context = this.canvas.getContext("2d");
			this.context.lineWidth 		= 1;
			this.context.strokeStyle 	= strokeStyle;

			//initialize our array of values
			this.values = this.getValues(this.arraySize);
		}

		//initialize an array of N numbers
		sort.prototype.getValues = function(numElements){
			for (var a=[],i=0;i<numElements;++i) a[i]=i;
			return this.shuffle(a);	
		}

		//randomize the values in the array
		sort.prototype.shuffle = function(array){
			var tmp, current, top = array.length;
			if(top) while(--top) {
				current = Math.floor(Math.random() * (top + 1));
				tmp = array[current];
				array[current] = array[top];
				array[top] = tmp;
			}
			return array;
		}

		//this function renders each value as a line
		//we use the magnitude of the value at element N is used as the length of the line
		//we use the index as the position of the line (all lines are veritcal)
		sort.prototype.draw = function(){
			//clear canvas
			this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

			//draw each of the values as a line 
			for (var i = 0; i < this.values.length; i++) {
				this.context.beginPath();
				this.context.moveTo(0, i+0.5);
				this.context.lineTo(this.values[i], i+0.5);
				this.context.stroke();
			}
		}

		//sort the array of values, and each time a swap occurs, redraw the values on the canvas
		//sort using a BUBBLE SORT algorithm
		sort.prototype.bubbleSort = function(){
			var swapped = false;

			//pass through the array and swap the first unordered value you find with its neighbour
			sort.prototype.bubbleSortPass = function(i){
				if (this.values[i] > this.values[i+1]) {
					var temp 			= this.values[i];
					this.values[i] 		= this.values[i+1];
					this.values[i+1] 	= temp;

					swapped = true;

					this.draw();
				}				

				//save the context so that we can call the functions with setTimeout in the context of our object
				var self = this;

				//These are our "loop" conditionals
				if(i<this.values.length){
					//if i<this.values.length, we are not yet at the end of our pass through the array (inner loop)
					setTimeout(function(){self.bubbleSortPass(i+1);}, 5);
				}else{
					//if i=this.values.length then we have completed a pass through the array
					//we check if any values were swapped during the last pass
					//if no, the array is sorted
					//if yes, then we need to do another pass
					if(swapped){setTimeout(function(){self.bubbleSort();}, 5);}
				}				
			}

			this.bubbleSortPass(0);
		}

		//sort the array of values, and each time a swap occurs, redraw the values on the canvas
		//sort using a SELECTION SORT algorithm
		sort.prototype.selectionSort = function(i){
			// current smallest value in the array
			var smallestValueIndex = i;

			// check against all other values
			for (var k = i+1; k < this.arraySize; k++) {

				// new small value, reference its position
				if (compare( this.values[k], this.values[smallestValueIndex]) === true) {
					smallestValueIndex = k;
				}
			}

			// a new smallest value was assigned, perform a swap !
			if (smallestValueIndex !== i) {
				var tmp 		= this.values[i];
				this.values[i] 	= this.values[smallestValueIndex];
				this.values[smallestValueIndex] = tmp;

				this.draw();
			}

			function compare(a, b) {
				return a < b ? true : b;
			}

			var self = this;
			if(i<this.arraySize){setTimeout(function(){self.selectionSort(i+1);}, 5);}	
		}

		//sort the array of values, and each time a swap occurs, redraw the values on the canvas
		//fort using an INSERTION SORT algorithm
		sort.prototype.insertionSort = function(){
    		var len = this.values.length, i = -1, j, tmp;
 
			while (len--) {
				tmp = this.values[++i];
				j = i;

				sort.prototype.insertionSortPass = function(j){
					if(this.values[j]>tmp && j>=0){
						this.values[j + 1] = this.values[j];
						this.values[j] = tmp;

						this.draw();

						var self = this;
						
						//totally fucked - why doesn't this work???
						//setTimeout(function(){self.insertionSortPass(j-1);},200);

						//works, but UI is locked until the thread exits
						self.insertionSortPass(j-1);
					}
				}
				this.insertionSortPass(j-1);
			}
		}

		$(document).ready(function(){

			var bubSort = new sort('canvas-bubble-sort','rgb(255,0,0)', 200);
			bubSort.draw();

			var selSort = new sort('canvas-selection-sort','rgb(0,255,0)', 200);
			selSort.draw();

			var insSort = new sort('canvas-insert-sort', 'rgb(0,0,255)', 200);
			insSort.draw();


			$("#btnBubbleSort").click(function(){
				bubSort.bubbleSort();
			});

			$("#btnSelectionSort").click(function(){
				selSort.selectionSort(0);
			});	

			$("#btnInsertionSort").click(function(){
				insSort.insertionSort();
			});
		});
	<script>
</body>  
</html>  
